# Staqueue Pattern
[日本語](index.md) | [English](index_EN.md) | [GitHub](https://github.com/stakiran/staqueue-pattern/)

## 概要

### スタッキュー
**スタッキュー(Staqueue)** とは、Stack と Queue を指します。特にこの二つのデータ構造を用いた情報管理を指します。

スタッキューでは、スタックとキューを用いてお望みの情報管理構造をつくります。たとえば普段のタスクリストとして queue1、割り込み用に stack1 と二つつくり、優先度を `stack1 > queue1` と設定すると、これは「普段は queue1 で先入れ先出し的に処理するが、割り込みが来たら stack1 で後入れ先出し的に処理しきる」運用となります。単純ですが、普段のタスクと割り込みの両方に対応するための基礎となります。

スタッキューではいくつか原則があります

- 情報管理とは個人の、個人による、個人のための情報を管理すること
    - 情報は TODO、タスク、アイデア、後で読むものなどあらゆるものが対象ですが、テキストとして表現されているものとします
    - 管理とは保存、閲覧、検索、 **処理（取り出し）**、別のスタッキューへの移動を含みます。 **編集操作は含みません**
- スタックとキューなので、以下の制約があります
    - スタックは後入れ先出しです。後に入れた情報が先に取り出されます
    - キューは先入れ先出しです。先に入れた情報が先に取り出されます
    - ランダムアクセス（任意番目の情報を操作）はしません。ただし閲覧と検索は可能です
    - 一度取り出した情報は削除されます（再投入は可能）
- 優先度があります
    - 優先度レイヤーがあり、高レイヤーのスタッキューから処理していきます

スタッキューの活用例

- 個人の情報管理（手作業）
- 個人の情報管理（ソフトウェア化する際のデータ構造）
- AIエージェント向けのデータ構造

### スタッキューパターン
デザインパターンのように、頻出するパターンを整理したものです。

### フォーマット
```
(ここにこのパターンの全体像を記す)
```

- (情報の処理)
    - どのスタッキューを処理するかを書きます
    - 処理とは「情報を取り出して行動に移すこと」です。取り出した情報は消えます
    - **いつ処理するかには言及しません**。随時、定期、反応的（通知が来たら等）等色々ありえますが、ここでは扱いません
- (情報の追加)
    - この構造にどうやって情報を追加するかを書きます
    - 外部からの追加と言えます。たいていは高レイヤーに、入口を担うスタッキューがあります
- (情報の移動)
    - いつ、どのスタッキューからスタッキューに情報を移動させるかを書きます
    - 内部での移動と言えます。より低レイヤーに向けて移ることが多いですが、逆方向もあります

### フォーマット例
全体像の例を示します。

```
Stack1 | Queue1
```

これは実際には次のような意味です。

```
High Prio <---   ---> Low Prio

(Layer1)   (Layer2)
 Stack1  |  Queue1
```

優先度と書きましたが、優先度が高いほどそのパターンにおいて「処理しやすい」「入口になりやすい」傾向があります。また順に低優先度に情報を移していくことが多いです。あくまでも傾向にすぎず、右から左に移すこともあれば、低優先度側で処理することもあります。

## ====

## 🔨task
- タスクの追加は「何を追加するか」を書きたい
- 処理した後に次に移す、は **ありえない** 点を強調したい
    - 処理して削除する or 処理せずに移動するの二択

## (基本)
基本的なパターンです。スタッキューを用いて情報管理を行うには、これらを押さえておくべきです。要点はここでも書いておきます:

- リストではなくキューを使うこと → FIFO ドリブンパターン
- 割り込みなど緊急性の高さに対応するために、スタックが使えること → ガードスタックパターン
- 通常キューは複数本運用し、何らかの観点に基づいて仕分ける → カテゴリーパターン

### FIFO ドリブンパターン
```
queue-main
queue-temp1
queue-temp2
...
```

- (情報の処理)
    - queue-main
- (情報の追加)
    - queue-main に追加する
- (情報の移動)
    - queue-main へのランダムアクセスや順序入れ替えがしたい場合、queue-tempXX を使う

最も基本的なパターンです。**タスクリストなどリストは使わず** キューを使います。つまり、FIFO（先に入れたタスクが先に取り出されます）し、ランダムアクセスはしません。

しかし、FIFO だけでは不便なことがあるので、queue-temp も使って良いとします。Temp の本数は任意ですが、できるだけ少ない方が良いです。少なければ少ないほどスタッキューパターンに適合できていることを示します。

このとおり **FIFO ドリブンで動くことは基本中の基本** です。

### ガードスタックパターン
```
stack1 | queue1
```

- (情報の処理)
    - stack1 を優先的に処理する。空になるまで処理する
    - stack1 が空のときは、queue1 を処理する
- (情報の追加)
    - 情報は queue1 に追加する
    - 割り込みが来たら stack1 に追加する
- (情報の移動)
    - なし

最も基本的なパターンの一つです。FIFO ドリブンだけだと、割り込みなど緊急性の高さに対応できませんので、スタックを導入します。

ガードスタックパターン自体は（単純化のため）Queue が一本ですが、もちろん FIFO ドリブンと組み合わせることもできます。

### カテゴリーパターン
```
queue-entrance | queue1
                 queue2
                 ...
```

- (情報の処理)
    - queueXX を処理する
- (情報の追加)
    - queue-entrance に追加する
- (情報の移動)
    - queue-entrance から適切な queueXX に移す。また queue-entrance は空にすることを心がける

頻出パターンです。多くの場合、キューが一本だと足りないので複数本にしますが、どのような観点で分けるかが問題となります。これを端的に解決するのにカテゴリーパターンが使えます。

なお queueXX のつくりかたは付録1を参照。

## (個人に関するパターン)
スタッキューパターンが想定するとおり、自分自身のみで完結するパターンです。

### レイターパターン
```
queue-main | stack-later
```

- (情報の処理)
    - queue-main を処理する
- (情報の追加)
    - 情報は queue-main に追加する
- (情報の移動)
    - あとでやりたいものは queue-main から stack-later に移す
    - あとでやりたいものを処理するために、stack-later から queue-main に戻す

レイター（Later）、つまりは「あとでやる」を実現するためのパターンです。

FIFO ドリブンは同一優先度で複数のキューを使い分けていましたが、レイターパターンでは一つ低いレイヤーにスタックを置いています。つまり「あとでやる」ものは、後に入れたものから取り出されます。溜まると底が見えなくなるので、早めに処理しようという気になりやすいです。

### プロジェクトパターン
```
stack-inbox | queue-inbox | stack1 or queue1 or stack1+queue1
                            stack2 or queue2 or stack2+queue2
                            ...     ...
```

- (情報の処理)
    - stack-inbox を最優先で処理する。空になるまで処理する
    - project staqueue（stackXX, queueXX, stackXX+queueXX のいずれか）は、その活動を行う際に処理する
- (情報の追加)
    - 割り込みなど緊急性の高いものは stack-inbox に追加する
    - 通常は queue-inbox に追加する
- (情報の移動)
    - queue-inbox から project staqueueXX に移す

まずプロジェクトごとにスタッキューを用意し、これらに振り分けるための queue-inbox を一つ置きます。カテゴリーパターンと似ていますが、カテゴリーパターンは queue しか使わないのに対して、プロジェクトパターンではスタック、キュー、スタックとキューの3種類が使えます。以下の違いを見てください。

```
カテゴリーパターン:

    queue | queue
            queue
            ...

プロジェクトパターン:

    queue | stack
            queue
            stack + queue
            ...
```

そして割り込みに対応するためにガードスタックパターンも追加します。具体的には stack-inbox を置いています。

私達は「プロジェクト」なるものを n 個抱えており、いつどのプロジェクトに取り組むかを一つずつ切り替えながら活動しているはずです。このパターンは、そのプロジェクトごとに一つの project staqueue を割り当てており、ここにカテゴリーパターン的な仕分けとガードスタック的な割り込み保護を追加しています。

注意点として、あまり複雑な活動は扱えません。このパターンはプロジェクトごとのスタッキューとして「スタックのみ」「キューのみ」「スタックとキューを一本ずつ」のみを想定しています。**これらより複雑なスタッキューは使いません**。

### 先送りパターン
```
prio1    prio2

queue1 | stack-immediately
         queue-1hour
         queue-3hour
         queue-day
         queue-tomorrorow
         queue-3day
         queue-next-week
```

- (情報の処理)
    - 優先度2のスタッキューを処理する
- (情報の追加)
    - queue1 に追加する
- (情報の移動)
    - queue1 から優先度2に移す。その際、いつまで先送りしていいかを判断して適切なスタッキューに移す

統一的に先送りを行うパターンです。まず queue1 で受け止めた後、それを「どこまで先送りしていいか」という主観的な判断に基づいて分類します。

先送りが難しい場合は stack-immediately を使います。それ以外の場合はキューを使いますが、延長時間は適当に調整してください。上記の例では 1 時間以内、3 時間以内、今日中、明日中、3 日以内、来週また検討する、の 6 パターンを置いています。また stack^immediately を複数本にしても構いません。

優先度 2 のスタッキューは 7 本以内にしてください。これ以上多いと判断が煩雑になって形骸化します。また、できるだけ少ない方が良いです。「必要最小限の本数で済むためには？」を追求するのがポイントです。

### 先送りの可視化パターン
```
queue-distributor | queue-0
                    queue-1
                    queue-2
                    queue-3
                    queue-long
```

- (情報の処理)
    - queue-XX を処理する
- (情報の追加)
    - queue-distributor に追加する。このとき情報には必ずタイムスタンプ（最低限日付は必要）をつける
- (情報の移動)
    - queue-distributor から queue-0 に移動する
    - queue-X から queue-X に移動する（入れ直す）
    - queue-X より下のキューに移動する

何日先送りしたかを可視化するパターンです。

まずは queue-0 で受け止め、ここを空にすることを目指します。その場で処理できない場合は queue-0 に入れ直します。このとき、その情報のタイムスタンプを見て、何日経過しているかで移動先を変えます。1 日経過しているなら queue-1 に、2 日経過しているなら queue-2、3 日なら queue-3、それ以上なら queue-long に入れます。

他の queue-XX も同様で、処理するときに取り出して、処理できたならそれで良し。処理できないなら XX に入れ直すか、経過日が増えてるならそちらのキューに入れます――と、こうしていくことで、何日先送りされたのかが整理されていきます。

### フェーズパターン
```
queue-inbox | queue-phase1 | queue-phase2 | ...
queue-NA
```

- (情報の処理)
    - queue-phaseXX を処理する
- (情報の追加)
    - queue-inbox に追加する
- (情報の移動)
    - queue-inbox から必要に応じて取り出して、queue-phase1 に移す
    - queue-phaseXX から取り出した情報は次のように対応する:
        - Phase XX にふさわしくない場合、Phase XX+1 に移す
        - ふさわしいが、今は処理できない場合は queue-phaseXX に入れる（入れ直す）
        - 最後の Phase でもふさわしくない場合、queue-NA に入れる（NA = Not Applicable）

まず始めにフェーズを設計してください。Phase-1 → Phase-2 → …… のように段階で区切る営みです。スケジュールやプロセスやサイクルといった「ビジネスライクな進め方」を使う文脈では多発するはずです。

この前提で、フェーズパターンを使うと、このような営みに対応できます。ポイントは「現在よりも後のフェーズで使うもの」と「もう過ぎたフェーズで使うべきだったもの」、そして「どのフェーズにも当てはまらないもの」が溜まることです。溜まり具合は一種の指標であり、**溜まれば溜まるほど危ない臭いがする** と考えます。

### クッションパターン
```
queue-inbox | stack-sleep | queue-sleep
```

- (情報の処理)
    - queue-sleep から取り出して「本当に処理するか？」を自問し、する場合は処理します
- (情報の追加)
    - 「すぐにも出したいが寝かせるべきもの」を queue-inbox に追加する
- (情報の移動)
    - queue-inbox から stack-sleep に移す
    - stack-sleep は時間を空けて確認し、取り出したものを queue-sleep に移す
        - 少なくとも queue-inbox への追加タイミングと一緒に確認するのは **やめてください**
    - queue-sleep は時間を空けて確認し、
        - 少なくとも stack-sleep への追加タイミングと一緒に確認するのは **やめてください**

すぐに出したいものをすぐに出してしまうと、ろくなことになりません。一度寝かせることで冷静になり、余計な行動をせずに済みます。このようなクッション行動を実現するためのパターンです。

考え方としては、まずスタックに入れて寝かせます。スタックですので入れたものが多いと、底に溜まっていきますが、これは意図的です。溜まれば見えづらくなり、寝かしやすくなるためです。次に、スタックから取り出したものはもう一度溜めます。今度はキューに入れます。そして、キューから取り出す頃には、おそらく冷静になっているはずです。

### GTD パターン
```
queue-inbox | queue-someday    | queue-projects | queue-nextactions
              queue-documents    queue-calendar
              queue-recyclebin   queue-waiting
```

- (情報の処理)
    - queue-nextactions を処理します。**随時かつ高頻度に処理するべきです**
    - queue-calendar を処理します。取り出したものが示す予定をカレンダーに追加します。**予定をすっぽかさない程度には高頻度に処理するべきです**
    - queue-documents を処理します。取り出したものが示す資料の所在を何らかの管理システムに追加するか、資料そのものの場合は適切な場所に保存します。キューが溜まらない程度の頻度で処理すれば良いです
- (情報の追加)
    - queue-inbox に追加します
    - queue-nextactions に追加します。基本的に queue-projects の中身を見ているときに思いつくはず
- (情報の移動)
    - queue-inbox から後続のキューに移します。以下のように仕分けます:
        - いつかやればいいもの → someday
        - ただの資料であり、必要に応じて参照すればいいもの → documents
        - 不要なもの → recycle bin
        - 具体的に行動可能で、行動すれば終われる「きりがいいもの」 → next actions
        - 具体的でないか、行動可能でないか、具体的で行動可能だが「きりがよくない」もの → projects
        - 予定として管理するべきもの → calendar
        - 相手からのリアクションが来ないと先に進まない事柄 → waiting
    - queue-project から queue-project に入れ直します（入れ直します）
        - 取り出したプロジェクトは「プロジェクトとして終了または中止するまで」は存在し続けるため、単に入れ直すことで存続させます

GTD® をスタッキューパターンで実装したものです。高度モデルは扱っていないことに注意してください。

※高度モデル：GTD のうち、目標やビジョンや価値観など、短期・中長期含む人生全体の整合性を持たせるための軸を管理する仕組み

GTD の肝は三つあります。「とにかくまずは inbox に放り込む」こと、「それを特殊な事柄に仕分けつつも、すぐに行動な可能なネクストアクションに分解する」こと、そして「たくさん溜まってるネクストアクションをとにかく消化すること」の三点です。これを素直に実装したのが、この GTD パターンです。

GTD はリストを用いて管理する人が多いかと思いますが、実はキューの方が運用しやすいです。なぜならキューだとキュー内が見えないため、機械的にキューから取り出して処理する or 移動する、という行動がしやすいからです。もちろん、人間でありながら、機械のように動くことになるので、合う・合わないは出ます。

### スリーポーリングパターン
```
queue-polling1
queue-polling2
queue-polling3
```

- (情報の処理)
    - queue-pollingXX を処理する
- (情報の追加)
    - 「相手に働きかけたいが、できるとは限らないため、ポーリングしないといけないもの」を queue-polling1 に追加する
- (情報の移動)
    - queue-pollingXX から取り出したものを処理しようとしたが、できなかった場合、それを XX+1 に移す
    - queue-polling3 でもできなかったものは削除する

たとえば A さんに話したいが、A さんは多忙ゆえに席に行っても捕まりにくいとします。また A さんの席は遠くて、通うのも大変だとします。このようなときは何回か試行してみて、ダメならいったん諦めるでしょう。このような状況で使えるパターンです。

その名前のとおり、3 回だけ頑張ります。まず queue-polling1 で管理して、試行するときはこのキューから取り出します。試行できたらそこで終わりですが、ダメだった場合は polling2 に移します。そうして 3 回目まで頑張ります。polling3 でもダメだった場合は、そこで諦めます。

queue-pollingXX に優先度をつけていないことに注目してください。ですので「今日は polling2 から取り出す」「今日は polling3 から取り出してみるか」など気分で決めて構いません。ずいぶん雑に見えるパターンですが、3 回も試行したんだぞとの言い分をつくれるので、心理的にはだいぶ楽になります。

### xxxパターン
```
```

- (情報の処理)
    - ...
- (情報の追加)
    - ...
- (情報の移動)
    - ...

### xxxパターン
```
```

- (情報の処理)
    - ...
- (情報の追加)
    - ...
- (情報の移動)
    - ...

## (チームに関するパターン)
スタッキューパターンは個人の、個人による、個人のためのものですが、チームで使うこともできます。

たとえば「レジ待ちパターン」では依頼者にどのキューに入れてもらうかを選ばせますし、「アサインパターン」ではメンバー各々が一つのスタックを持っていることを想定します。前者を **追加の委譲** と呼び、後者を **スタッキューの付与** と呼びます。

チームに関するパターンでも「自分自身のためのシステムを運用すること」は遵守します。その上で、少しだけ他メンバーに関与させることによって、チームにおける課題に対応します。その「少しだけ関与させる方法」がいくつかあるのです:

- 追加の委譲: スタッキューに情報を追加する部分をやってもらう
- スタッキューの付与: スタッキューを持たせて、運用してもらう
- ...

### レジ待ちパターン
```
queue1
queue2
...
```

- (情報の処理)
    - queueXX を処理する
- (情報の追加)
    - **あなたではなく依頼者が追加する**。依頼を queueXX に追加する。どこに追加するかは、すべての queueXX を眺めた上で決めて良い
- (情報の移動)
    - なし

現実世界でもよく見られる光景で、n 本の待ち列を見てどこに並ぶかを選びます。

本パターン集の文脈（個人的な情報管理）に従うと、このパターンは自分に依頼してくる者に向けたものであり、まず自分が抱えるキューを公開した上で、依頼者にはどのキューに並ぶか（依頼を投げるか）を判断してもらうためのものです。

- Before
    - 依頼者は、あなたに、おそらく口頭やメールやチャットなどで依頼をする
- After
    - 依頼者は、あなたが用意したレジ待ちキューを眺めて、どこに依頼するかを判断した上で依頼を追加する
    - 依頼者は、レジ待ちキューを見ることで、あなたの対応状況を知る

キューの公開と状況反映の手間こそありますが、キューが共通言語となりますし、キューのコントロール次第で状況をコントロールできるため自分も依頼者も双方楽になります。

### アサインパターン
```
queue-inbox | stack-member1
              stack-member2
              ...
```

- (情報の処理)
    - メンバーXXは自分のスタック stack-memberXX を処理する
- (情報の追加)
    - マネージャーまたはメンバーが queue-inbox に追加する
- (情報の移動)
    - マネージャーが queue-inbox から stack-memberXX に移動する

作業的なタスクをひたすらこなす状況において、n 人のメンバーにタスクをアサインするときに使えるパターンです。

**1人1スタックを持っています**。スタックですので「後から来たものを先に処理する」形になり、割り込みにも自然に対応できます。またアサインが多すぎると底に溜まってしまいますが、これはアサインの仕方が悪いと結論付けます。アサインの頻度を減らしたり、スタック（つまりはメンバー）を増やすサインです。

### テイクパターン
```
queue-inbox | stack-member1
              stack-member2
              ...
```

- (情報の処理)
    - メンバーXXは自分のスタック stack-memberXX を処理する
- (情報の追加)
    - マネージャーまたはメンバーが queue-inbox に追加する
- (情報の移動)
    - メンバーが queue-inbox から stack-memberXX に移動する。ただし自分では処理できそうにないなら queue-inbox に戻す
        - **queue-inbox に戻せるタイミングは「queue-inbox から取り出した直後」に限定してください**。でないと勝手に inbox に戻されてしまって破綻します。

アサインパターンの亜種です。アサインパターンはマネージャー役がメンバーにアサインをしていましたが、このパターンではメンバーが自発的に inbox から取りに行きます。

## ====

## 付録

### 付録1: カテゴリーパターンにおけるカテゴリーのつくりかた
好きにすれば良いが、よく知られた軸があるため参考にすると良い。

- (文脈軸)
    - プロジェクトごと
    - 人物ごと
    - 締切目安ごと
        - たとえば「今日やる」「明日までにやる」「今週中にやる」「それ以降でいい」の 4 本
        - 日付は毎日更新されるので、毎日更新が必要。手動だと厳しい
- (主観軸)
    - 主観的な難易度ごと
        - たとえば高（頭か神経か両方を酷使する）、中（努力は必要だがまあできる）、低（時間かけたらできるもの）
    - 主観的な疲労感ごと
        - たとえば高（実施タイミング考えないとこなせないくらい疲れる）、中（いつでもできるが疲れる）、低（いつでもできる）
    - 好き、嫌い、どっちでもない・どうでもいいの 3 本
    - やりたい、やりたくないの 2 本
    - Must、Should、Want の 3 本

また私が整理した「タスクの属性一覧」も参考になるだろう:

- [List of "Task Attributes" for Implementing Task Management - DEV Community](https://dev.to/stakiran/list-of-task-attributes-for-implementing-task-management-5e87)
